{"version":3,"sources":["VTKStreamlit.tsx","index.tsx"],"names":["VTKStreamlit","viewerRef","useRef","clearRef","renderData","useStreamlit","React","useState","viewerState","setViewerState","undefined","file","setFile","initialLoad","useEffect","args","current","currFile","a","b","byteLength","every","val","i","loadFile","useCallback","config","Blob","dispatch","type","skipRender","toolbar","useMemo","sider","cssStyle","height","includes","Streamlit","setFrameHeight","parseInt","replace","border","borderRadius","setComponentValue","handleScreenshot","then","notification","success","message","placement","style","width","display","flexDirection","Content","ref","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7121c5b8.chunk.js","sourcesContent":["import React, { useCallback, useEffect, useMemo, useRef } from \"react\"\n\nimport { Streamlit } from \"streamlit-component-lib\"\nimport { useStreamlit } from \"streamlit-component-lib-react-hooks\"\n\nimport { VTKViewer, VTKViewerDrawer, VTKFloatingToolbar } from \"lavender-vtkjs\"\n\nimport { Layout, notification } from \"antd\"\n\nimport './VTKStreamlit.css'\n\n// compare TypedArrays\n// https://stackoverflow.com/questions/21553528/how-to-test-for-equality-in-arraybuffer-dataview-and-typedarray\nconst compareTypedArrays: (a: Uint8Array, b: Uint8Array) => boolean = (a, b) => {\n  if (a.byteLength !== b.byteLength) return false;\n  return a.every((val, i) => val === b[i]);\n}\n\nconst VTKStreamlit: React.FunctionComponent = () => {\n  const viewerRef = useRef<any>(null)\n  const clearRef = useRef<boolean>(true)\n\n  const renderData = useStreamlit()\n\n  const [viewerState, setViewerState] = React.useState<any>({})\n\n  const [file, setFile] = React.useState<Uint8Array | undefined>(undefined)\n\n  const initialLoad = useRef(true)\n\n  useEffect(() => {\n    if (renderData && typeof renderData.args[\"clear\"] !== undefined) {\n      clearRef.current = renderData.args[\"clear\"]\n    }\n  }, [renderData])\n\n  useEffect(() => {\n    if (renderData && renderData.args[\"file\"]) {\n      setFile(currFile => {\n        if (!currFile) return renderData.args[\"file\"]\n        const equal = compareTypedArrays(renderData.args[\"file\"], currFile)\n        return equal ? currFile : renderData.args[\"file\"]\n      })\n    }\n  }, [renderData])\n\n  const loadFile = useCallback((file: Uint8Array) => {\n    const config = initialLoad.current ? undefined : viewerState\n    initialLoad.current = false\n    viewerRef.current.loadFile(new Blob([file]), 'vtkjs', config)\n  }, [viewerState])\n\n  useEffect(() => {\n    if (!file) return\n    if (viewerRef.current && viewerRef.current.loadFile) {\n      if (clearRef.current) viewerRef.current.dispatch({ type: 'remove-all', skipRender: true })\n      loadFile(file)\n      if (clearRef.current) viewerRef.current.dispatch({ type: 'reset-camera' })\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [file])\n\n  const toolbar = useMemo(() => {\n    if (renderData && typeof renderData.args[\"toolbar\"] !== 'undefined') {\n      return renderData.args[\"toolbar\"]\n    }\n    else {\n      return true\n    }\n  }, [renderData])\n\n  const sider = useMemo(() => {\n    if (renderData && typeof renderData.args[\"sider\"] !== 'undefined') {\n      return renderData.args[\"sider\"]\n    }\n    else {\n      return true\n    }\n  }, [renderData])\n\n  const cssStyle = useMemo(() => {\n    if (renderData && typeof renderData.args[\"style\"] !== 'undefined') {\n      if (renderData.args[\"style\"].height && renderData.args[\"style\"].height.includes('px')) {\n        Streamlit.setFrameHeight(parseInt(renderData.args[\"style\"].height.replace('px', '')))\n      }\n      return renderData.args[\"style\"]\n    }\n    else {\n      return { border: \"1px solid #d0d7de\", borderRadius: \"2px\" }\n    }\n  }, [renderData])\n\n  useEffect(() => {\n    if (renderData && renderData.args[\"subscribe\"]) {\n      Streamlit.setComponentValue(viewerState)\n    }\n  }, [viewerState])\n\n  const handleScreenshot = () => {\n    if (!viewerRef.current) return\n    viewerRef.current.handleScreenshot('VTKJSStreamlit')\n      .then(() => {\n        notification.success({\n          message: `Copied to Clipboard`,\n          placement: 'topRight',\n        });\n      })\n  }\n\n  if (renderData == null) {\n    return null\n  }\n\n  return (\n    <div style={{ width: '100%', height: '100%', border: \"1px solid #d0d7de\", borderRadius: \"2px\", ...cssStyle, display: 'flex' }}>\n      <Layout style={{ flexDirection: 'row' }}>\n        {sider &&\n          <VTKViewerDrawer dispatch={viewerRef.current?.dispatch} viewerState={viewerState} handleScreenshot={handleScreenshot} />\n        }\n        <Layout>\n          {toolbar &&\n            <VTKFloatingToolbar dispatch={viewerRef.current?.dispatch} viewerState={viewerState} handleScreenshot={handleScreenshot} />\n          }\n          <Layout.Content style={{ display: 'flex', flexDirection: 'column' }}>\n            <VTKViewer setViewerState={setViewerState} ref={viewerRef} />\n          </Layout.Content>\n        </Layout>\n      </Layout>\n    </div>\n  )\n}\n\nexport default VTKStreamlit","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { ErrorBoundary } from \"streamlit-component-lib-react-hooks\"\nimport VTKStreamlit from \"./VTKStreamlit\"\n\nimport 'antd/dist/antd.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <ErrorBoundary>\n      <VTKStreamlit />\n    </ErrorBoundary>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}