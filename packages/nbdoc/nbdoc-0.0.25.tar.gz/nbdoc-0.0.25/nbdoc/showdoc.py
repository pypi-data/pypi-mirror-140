# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/showdoc.ipynb (unless otherwise specified).

__all__ = ['is_valid_xml', 'param2JSX', 'np2jsx', 'fmt_sig_param', 'get_sig_section', 'get_jsx_doc']

# Cell
from numpydoc.docscrape import NumpyDocString,ClassDoc, FunctionDoc, Parameter
from fastcore.all import test_eq, get_source_link, test
from xml.etree import ElementTree as et
import inspect, functools

# Cell
_ATTRS_PARAMS=['Parameters', 'Attributes', 'Returns', 'Yields', 'Raises'] # These have parameters
_ATTRS_STR_LIST=['Summary', 'Extended Summary'] # These are lists of strings
def _is_func(obj): return inspect.isfunction(obj)

# Cell
def is_valid_xml(xml:str):
    "Determine if xml is valid or not."
    try: et.fromstring(xml)
    except et.ParseError as e:
        print(f"WARNING: xml not does not parse:{e}")
        return False
    return True

# Cell
def param2JSX(p:Parameter):
    "Format a numpydoc.docscrape.Parameters as JSX components"
    prefix = "<Parameter"
    suffix = " />"
    for a in ['name', 'type', 'desc']:
        val = getattr(p, a)
        if val:
            if a == 'desc':
                desc = '\n'.join(val).encode('unicode_escape').decode('utf-8')
                prefix += f' {a}="{desc}"'
            else: prefix += f' {a}="{val}"'
    return prefix.strip() + suffix

# Cell
def np2jsx(obj):
    "Turn Numpy Docstrings Into JSX components"
    if inspect.isclass(obj): doc = ClassDoc(obj)
    elif _is_func(obj): doc = FunctionDoc(obj)
    else: raise ValueError(f'You can only generate parameters for classes and functions but got: {type(obj)}')
    desc_list = []
    for a in _ATTRS_STR_LIST:
        nm = a.replace(' ', '_').lower()
        desc = '\n'.join(doc[a]).encode('unicode_escape').decode('utf-8')
        if doc[a]: desc_list.append(f' {nm}="{desc}"')
    desc_props = ''.join(desc_list)
    desc_component = f'<Description{desc_props} />' if desc_props else ''

    jsx_sections = []
    for a in _ATTRS_PARAMS:
        params = doc[a]
        if params:
            jsx_params = '\t' + '\n\t'.join([param2JSX(p) for p in params])
            jsx_block = f'<ParamSection name="{a}">\n{jsx_params}\n</ParamSection>'
            jsx_sections.append(jsx_block)

    return desc_component+ '\n' + '\n'.join(jsx_sections)

# Cell
def fmt_sig_param(p:inspect.Parameter):
    "Format inspect.Parameters as JSX components"
    name = str(p) if str(p).startswith('*') else p.name
    prefix = f'<SigArg name="{name}" '
    if p.annotation != inspect._empty:
        prefix += f'type="{p.annotation.__name__}" '
    if p.default != inspect._empty:
        prefix += f'default="{p.default}" '
    return prefix + "/>"

# Cell
def get_sig_section(obj):
    "Get JSX section from the signature of a class or function consisting of all of the argument."
    if not inspect.isclass(obj) and not _is_func(obj):
        raise ValueError(f'You can only generate parameters for classes and functions but got: {type(obj)}')
    params = inspect.signature(obj).parameters.items()
    jsx_params = [fmt_sig_param(p) for _, p in params]
    return "<SigArgSection>\n" + ''.join(jsx_params) +"\n</SigArgSection>"

# Cell
def get_jsx_doc(obj):
    "Construct the full JSX documentation for a particular object."
    if _is_func(obj):
        if 'self' in inspect.signature(ex.ExampleClass.example_method).parameters:
            typ = 'method'
        else: typ = 'function'
    elif inspect.isclass(obj):
        typ = 'class'
    else:
        raise ValueError(f'Can only parse a class or a function, but got a {type(obj)}')
    npdocs = np2jsx(obj)
    nm = f'<DocSection type="{typ}" name="{obj.__name__}" module="{inspect.getmodule(obj).__name__}" link="{get_source_link(obj)}">'
    sp = get_sig_section(obj)
    return f'{nm}\n{sp}\n{npdocs}\n</DocSection>'