{"version":3,"sources":["commitsView.es6.js"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,WAAH,GAAiB,EAAE,CAAC,cAAH,CAAkB,MAAlB,CAAyB;AACtC,EAAA,SAAS,EAAE,SAD2B;AAEtC,EAAA,YAAY,EAAE,EAAE,CAAC,UAFqB;;AAItC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,EAAA,UAfsC,sBAe3B,OAf2B,EAelB;AAChB,IAAA,EAAE,CAAC,cAAH,CAAkB,SAAlB,CAA4B,UAA5B,CAAuC,IAAvC,CAA4C,IAA5C,EAAkD,OAAlD;AAEA,SAAK,iBAAL,GAAyB,OAAO,CAAC,gBAAjC;AACA,SAAK,gBAAL,GAAwB,KAAxB;AACH,GApBqC;;AAsBtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,EAAA,MAhCsC,oBAgC7B;AACL,IAAA,EAAE,CAAC,cAAH,CAAkB,SAAlB,CAA4B,MAA5B,CAAmC,IAAnC,CAAwC,IAAxC;;AAEA,SAAK,iBAAL,CAAuB,MAAvB,CAA8B,KAAK,cAAL,CAAoB,IAApB,CAAyB,IAAzB,CAA9B;;AAEA,WAAO,IAAP;AACH,GAtCqC;;AAwCtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,EAAA,UAlDsC,sBAkD3B,MAlD2B,EAkDnB;AACf,SAAK,KAAL,CAAW,OAAX,CAAmB,UAAA,IAAI,EAAI;AACvB,UAAI,IAAI,CAAC,KAAL,KAAe,MAAnB,EAA2B;AACvB,QAAA,IAAI,CAAC,YAAL;AACH,OAFD,MAEO;AACH,QAAA,IAAI,CAAC,cAAL;AACH;AACJ,KAND;AAOH,GA1DqC;;AA4DtC;AACJ;AACA;AACI,EAAA,aA/DsC,2BA+DtB;AACZ,SAAK,KAAL,CAAW,OAAX,CAAmB,UAAA,IAAI;AAAA,aAAI,IAAI,CAAC,cAAL,EAAJ;AAAA,KAAvB;AACH,GAjEqC;;AAmEtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,EAAA,cA9EsC,4BA8ErB;AAAA;;AACb,QAAI,KAAK,gBAAT,EAA2B;AACvB;AACH;;AAED,QAAM,UAAU,GAAG,KAAK,UAAxB;AACA,QAAM,iBAAiB,GAAG,KAAK,iBAAL,CAAuB,CAAvB,CAA1B;AACA,QAAM,iBAAiB,GAAG,EAA1B;;AAEA,QAAI,UAAU,CAAC,YAAX,MACC,iBAAiB,CAAC,SAAlB,GAA8B,iBAAiB,CAAC,YAAjD,GACC,iBAAiB,CAAC,YAAlB,GAAiC,iBAFtC,EAE0D;AACtD,WAAK,gBAAL,GAAwB,IAAxB;AAEA,MAAA,UAAU,CAAC,SAAX,CAAqB;AACjB,QAAA,OAAO,EAAE,mBAAM;AACX,UAAA,KAAI,CAAC,gBAAL,GAAwB,KAAxB;;AAEA,cAAI,UAAU,CAAC,YAAX,EAAJ,EAA+B;AAC3B;AACxB;AACA;AACA;AACA;AACwB,YAAA,KAAI,CAAC,cAAL;AACH;AACJ,SAZgB;AAajB,QAAA,KAAK,EAAE,eAAC,UAAD,EAAa,GAAb,EAAqB;AACxB,UAAA,KAAI,CAAC,gBAAL,GAAwB,KAAxB;;AACA,UAAA,KAAI,CAAC,OAAL,CAAa,WAAb,EAA0B,GAA1B;AACH;AAhBgB,OAArB;AAkBH;AACJ;AA/GqC,CAAzB,CAAjB","file":"commitsView.js","sourcesContent":["/**\n * A view that lists a series of commits.\n *\n * This is intended to be used for creating new review requests from committed\n * revisions. The containing view can call setPending/cancelPending to ask an\n * individual commit to show a spinner.\n */\nRB.CommitsView = RB.CollectionView.extend({\n    className: 'commits',\n    itemViewType: RB.CommitView,\n\n    /**\n     * Initialize the view.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the view.\n     *\n     * Option Args:\n     *     $scrollContainer (jQuery):\n     *         The parent container handling all content scrolling.\n     */\n    initialize(options) {\n        RB.CollectionView.prototype.initialize.call(this, options);\n\n        this._$scrollContainer = options.$scrollContainer;\n        this._fetchingCommits = false;\n    },\n\n    /**\n     * Render the view.\n     *\n     * Delegates the hard work to the parent class, and sets up the scroll\n     * handler.\n     *\n     * Returns:\n     *     RB.CommitsView:\n     *     This object, for chaining.\n     */\n    render() {\n        RB.CollectionView.prototype.render.call(this);\n\n        this._$scrollContainer.scroll(this.checkFetchNext.bind(this));\n\n        return this;\n    },\n\n    /**\n     * Set a given commit \"pending\".\n     *\n     * This is used while creating a new review request, and will ask the\n     * correct commit view to show a spinner.\n     *\n     * Args:\n     *     commit (RB.RepositoryCommit):\n     *         The selected commit.\n     */\n    setPending(commit) {\n        this.views.forEach(view => {\n            if (view.model === commit) {\n                view.showProgress();\n            } else {\n                view.cancelProgress();\n            }\n        });\n    },\n\n    /**\n     * Cancel the pending state on all commits.\n     */\n    cancelPending() {\n        this.views.forEach(view => view.cancelProgress());\n    },\n\n    /**\n     * Check whether we need to fetch more commits.\n     *\n     * Commits need to be fetched if the scroll container hasn't been filled\n     * yet (due to too few commits for the available window height) or if\n     * the user has scrolled close to the end of the scroll container.\n     *\n     * Once new commits have been fetched, they'll be rendered, and an\n     * immediate check will be performed to see if we still need to fetch\n     * more commits, in case the scroll container is still not filled.\n     */\n    checkFetchNext() {\n        if (this._fetchingCommits) {\n            return;\n        }\n\n        const collection = this.collection;\n        const scrollContainerEl = this._$scrollContainer[0];\n        const scrollThresholdPx = 50;\n\n        if (collection.canFetchNext() &&\n            (scrollContainerEl.scrollTop + scrollContainerEl.offsetHeight) >\n            (scrollContainerEl.scrollHeight - scrollThresholdPx)) {\n            this._fetchingCommits = true;\n\n            collection.fetchNext({\n                success: () => {\n                    this._fetchingCommits = false;\n\n                    if (collection.canFetchNext()) {\n                        /*\n                         * There may still be room left for more commits.\n                         * We need to populate past the scroll point, so\n                         * check again.\n                         */\n                        this.checkFetchNext();\n                    }\n                },\n                error: (collection, xhr) => {\n                    this._fetchingCommits = false;\n                    this.trigger('loadError', xhr);\n                },\n            });\n        }\n    },\n});\n"]}