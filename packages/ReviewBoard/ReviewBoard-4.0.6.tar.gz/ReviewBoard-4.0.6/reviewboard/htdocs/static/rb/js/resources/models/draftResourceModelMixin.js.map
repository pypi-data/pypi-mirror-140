{"version":3,"sources":["draftResourceModelMixin.es6.js"],"names":[],"mappings":"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","file":"draftResourceModelMixin.js","sourcesContent":["/**\n * Mixin for resources that have special \"draft\" URLs.\n *\n * Some resources contain a \"draft/\" singleton URL that will either redirect to\n * the URL for an existing draft, or indicate there's no draft (and requiring\n * that one be created).\n *\n * These resources need a little more logic to look up the draft state and\n * craft the proper URL. They can use this mixin to do that work for them.\n */\nRB.DraftResourceModelMixin = {\n    /**\n     * Call a function when the object is ready to use.\n     *\n     * If the object is unloaded, we'll likely need to grab the draft\n     * resource, particularly if we haven't already retrieved a draft.\n     *\n     * Otherwise, we delegate to the parent's ready().\n     *\n     * Args:\n     *     options (object):\n     *         Options for the operation, including callbacks.\n     *\n     *     context (object):\n     *         Context to bind when calling callbacks.\n     */\n    ready(options, context) {\n        if (!this.get('loaded') && this.isNew() &&\n            this._needDraft === undefined) {\n            this._needDraft = true;\n        }\n\n        if (this._needDraft) {\n            /*\n             * Start by delegating to the parent ready() function. Because the\n             * object is \"new\", this will make sure that the parentObject is\n             * ready.\n             */\n            _super(this).ready.call(\n                this,\n                _.defaults({\n                    ready: () => this._retrieveDraft(options, context),\n                }, options),\n                context);\n        } else {\n            _super(this).ready.call(this, options, context);\n        }\n    },\n\n    /**\n     * Destroy the object.\n     *\n     * If destruction is successful, we'll reset the needDraft state so we'll\n     * look up the draft the next time an operation is performed.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the operation, including callbacks.\n     *\n     *     context (object):\n     *         Context to bind when calling callbacks.\n     */\n    destroy(options, context) {\n        options = _.bindCallbacks(options || {});\n\n        this.ready(\n            _.defaults({\n                ready: () => {\n                    _super(this).destroy.call(\n                        this,\n                        _.defaults({\n                            success: (...args) => {\n                                /* We need to fetch the draft resource again. */\n                                this._needDraft = true;\n\n                                if (_.isFunction(options.success)) {\n                                    options.success.apply(context, args);\n                                }\n                            }\n                        }, options),\n                        this);\n                }\n            }, options),\n            this);\n    },\n\n    /**\n     * Return the URL to use when syncing the model.\n     *\n     * Custom URL implementation which will return the special draft resource\n     * if we have yet to redirect and otherwise delegate to the prototype\n     * implementation.\n     *\n     * Returns:\n     *     string:\n     *     The URL to use for the resource.\n     */\n    url() {\n        if (this._needDraft) {\n            const parentObject = this.get('parentObject');\n            const linkName = _.result(this, 'listKey');\n            const links = parentObject.get('links');\n\n            /*\n             * Chrome hyper-aggressively caches things it shouldn't, and\n             * appears to do so in a subtly broken way.\n             *\n             * If we do a DELETE on a reply's URL, then later a GET (resulting\n             * from a redirect from a GET to draft/), Chrome will somehow get\n             * confused and associate the GET's caching information with a 404.\n             *\n             * In order to prevent this, we need to make requests to draft/\n             * appear unique. We can do this by appending the timestamp here.\n             * Chrome will no longer end up with broken state for our later\n             * GETs.\n             *\n             * Much of this is only required in the case of sqlite, which,\n             * with Django, may reuse row IDs, causing problems when making\n             * a reply, deleting, and making a new one. In production, this\n             * shouldn't be a problem, but it's very confusing during\n             * development.\n             */\n            return links[linkName].href + 'draft/?' + $.now();\n        } else {\n            return _super(this).url.call(this);\n        }\n    },\n\n    /**\n     * Try to retrieve an existing draft from the server.\n     *\n     * This uses the special draft/ resource within the resource list, which\n     * will redirect to an existing draft if one exists.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the operation, including callbacks.\n     *\n     *     context (object):\n     *         Context to bind when calling callbacks.\n     */\n    _retrieveDraft(options={}, context=undefined) {\n        if (!RB.UserSession.instance.get('authenticated')) {\n            if (options.error) {\n                options.error.call(context, {\n                    errorText: gettext('You must be logged in to retrieve the draft.')\n                });\n            }\n\n            return;\n        }\n\n        let data = options.data || {};\n        const extraQueryArgs = _.result(this, 'extraQueryArgs', {});\n\n        if (!_.isEmpty(extraQueryArgs)) {\n            data = _.extend({}, extraQueryArgs, data);\n        }\n\n        Backbone.Model.prototype.fetch.call(this, {\n            data: data,\n            processData: true,\n            success: () => {\n                /*\n                 * There was an existing draft, and we were redirected to it\n                 * and pulled data from it. We're done.\n                 */\n                this._needDraft = false;\n\n                if (options && _.isFunction(options.ready)) {\n                    options.ready.call(context);\n                }\n            },\n            error: (model, xhr) => {\n                if (xhr.status === 404) {\n                    /*\n                     * We now know we don't have an existing draft to work with,\n                     * and will eventually need to POST to create a new one.\n                     */\n                    this._needDraft = false;\n                    options.ready.call(context);\n                } else if (options && _.isFunction(options.error)) {\n                    options.error.call(context, xhr, xhr.status);\n                }\n            }\n        });\n    }\n};\n"]}