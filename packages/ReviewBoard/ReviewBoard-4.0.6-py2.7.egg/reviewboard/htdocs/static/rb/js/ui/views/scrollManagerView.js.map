{"version":3,"sources":["scrollManagerView.es6.js"],"names":[],"mappings":"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","file":"scrollManagerView.js","sourcesContent":["/**\n * Manages behavior and UI related to scrolling the page.\n *\n * This can be used by the UI to track pending and completed updates to\n * elements that might affect the current scroll position, such as new content\n * being injected into the DOM or being hidden/shown. When such updates occur\n * that would cause a page jump, the scroll manager will fix the scroll\n * position to counteract the jump.\n *\n * When a view is ready to make a DOM change that would impact the display or\n * size of an element, it should call\n * :js:func:`RB.ScrollManagerView.markForUpdate` before updating the element.\n * After, it should call :js:func:`RB.ScrollManagerView.markUpdates`.\n *\n * Views that create floating elements at the top of the page (such as banners)\n * should increment :js:attr:`RB.ScrollManagerView.scrollYOffset` by the height\n * of the element, and decrement it when the element goes away. This will\n * ensure that when navigating to an element through the scroll manager that\n * the height of the floating element will be taken into consideration for\n * the positioning.\n *\n * Attributes:\n *     scrollYOffset (number):\n *         The offset to add when scrolling to a target element or position.\n *         Callers should only increment or decrement this, and should never\n *         set it directly.\n */\nRB.ScrollManagerView = Backbone.View.extend({\n    /**\n     * Initialize the scroll manager.\n     */\n    initialize() {\n        this.scrollYOffset = 0;\n\n        // This is used so that unit tests can create a dummy window.\n        this.window = window;\n\n        this._updateScrollPosScheduled = false;\n        this._pendingElements = new Map();\n        this._elements = new Map();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n    },\n\n    /**\n     * Scroll to a specific element on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element to scroll to.\n     */\n    scrollToElement($el) {\n        this.scrollToPosition($el.offset().top);\n    },\n\n    /**\n     * Scroll to a specific position on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     scrollY (number):\n     *         The Y position to scroll to.\n     */\n    scrollToPosition(scrollY) {\n        this._oldScrollY = scrollY;\n\n        /*\n         * We use this instead of a flag being passed around to functions\n         * because we might actually end up using a pre-scheduled update to\n         * the scroll position, rather than scheduling a new one.\n         */\n        this._useScrollYOffset = true;\n\n        /* Attempt to immedialely scroll to the desired position. */\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        /*\n         * Chrome (and possibly other browsers in the future) attempt to be\n         * smart about restoring the initial scroll position after the page\n         * has fully loaded. However, we want to control the position in this\n         * case (probably in response to something in the URL we're handling),\n         * so we want to disable Chrome's behavior. Fortunately, there's an\n         * API for that.\n         */\n        if ('scrollRestoration' in history) {\n            history.scrollRestoration = 'manual';\n        }\n\n        this._scheduleUpdateScrollPos(true);\n    },\n\n    /**\n     * Mark an element for update.\n     *\n     * This should be called when an element will be updated with new\n     * content/size/visibility. The current state of the element will be\n     * tracked. When the update has finished, :js:func:`markUpdated` should\n     * be called to finalize the update.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element being updated.\n     */\n    markForUpdate($el) {\n        console.assert($el.length === 1);\n\n        const oldOffset = $el.offset();\n\n        this._pendingElements.set($el[0], {\n            oldHeight: $el.outerHeight(),\n            oldOffset: {\n                left: oldOffset.left,\n                top: oldOffset.top,\n            },\n        });\n\n        if (this._oldScrollY === null) {\n            this._oldScrollY = this.window.pageYOffset;\n        }\n    },\n\n    /**\n     * Mark an element as having been updated.\n     *\n     * This will schedule a scroll position update, factoring in the size\n     * and position differences for the element and helping prevent a page\n     * jump if the update occurred before the current scroll position.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element that was updated.\n     */\n    markUpdated($el) {\n        console.assert($el.length === 1);\n\n        const el = $el[0];\n        const elInfo = this._pendingElements.get(el);\n\n        if (elInfo) {\n            elInfo.newHeight = $el.outerHeight();\n            elInfo.newOffset = $el.offset();\n\n            this._elements.set(el, elInfo);\n            this._pendingElements.delete(el);\n        }\n\n        this._scheduleUpdateScrollPos();\n    },\n\n    /**\n     * Schedule an update for the scroll position.\n     *\n     * This will schedule the scroll position to be updated to take into\n     * account any updated elements. The update will happen in the next\n     * available animation frame. Only one will ever be scheduled at a time.\n     */\n    _scheduleUpdateScrollPos() {\n        if (!this._updateScrollPosScheduled) {\n            this._updateScrollPosScheduled = true;\n\n            /*\n             * Ideally we would update the DOM and set the scroll position at\n             * the same time, synchronized, without waiting for an animation\n             * frame and preventing any kind of a jump. This would work okay\n             * in some browsers (Chrome and Firefox are pretty good at not\n             * jumping), but some -- Safari (as of 10.1), Internet Explorer\n             * (as of 11), and Edge (as of 38.14393) -- will still jump after\n             * our code executes.\n             *\n             * We can minimize that jump by performing the scroll update during\n             * an animation frame, getting it as close as possible to the DOM\n             * layout update.\n             */\n            this.window.requestAnimationFrame(\n                this._updateScrollPos.bind(this));\n        }\n    },\n\n    /**\n     * Update the scroll position to factor in any element updates.\n     *\n     * This will look for any tracked elements that have been updated\n     * earlier in the page (before the current scroll position). It will\n     * then update the scroll position to take those updates into account,\n     * helping prevent a page jump.\n     */\n    _updateScrollPos() {\n        const elInfos = [];\n\n        this._elements.forEach((elInfo, el) => {\n            /*\n             * Check if the element remained the same size. We can ignore\n             * these.\n             */\n            if (elInfo.oldHeight !== elInfo.newHeighht) {\n                elInfo.el = el;\n                elInfos.push(elInfo);\n            }\n        });\n\n        let scrollY = this._oldScrollY;\n\n        if (this._useScrollYOffset) {\n            scrollY -= this.scrollYOffset;\n        }\n\n        if (elInfos.length > 0) {\n            /* Try to put these in order by position. */\n            elInfos.sort((a, b) => a.newOffset.top - b.newOffset.top);\n\n            for (let i = 0; i < elInfos.length; i++) {\n                const elInfo = elInfos[i];\n\n                /* Check if the element precedes the current scroll position. */\n                if (elInfo.newOffset.top + elInfo.newHeight < scrollY) {\n                    scrollY += (elInfo.newHeight - elInfo.oldHeight) +\n                               (elInfo.newOffset.top - elInfo.oldOffset.top);\n                }\n            }\n        }\n\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        this._elements.clear();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n        this._updateScrollPosScheduled = false;\n    },\n});\n\n\nRB.scrollManager = new RB.ScrollManagerView();\n"]}