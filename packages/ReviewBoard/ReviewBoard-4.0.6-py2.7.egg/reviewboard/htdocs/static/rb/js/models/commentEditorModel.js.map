{"version":3,"sources":["commentEditorModel.es6.js"],"names":[],"mappings":"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","file":"commentEditorModel.js","sourcesContent":["/**\n * Represents the state for editing a new or existing draft comment.\n *\n * From here, a comment can be created, edited, or deleted.\n *\n * This will provide state on what actions are available on a comment,\n * informative text, dirty states, existing published comments on the\n * same region this comment is on, and more.\n *\n * Attributes:\n *     canDelete (boolean):\n *         Whether the draft comment can be deleted.\n *\n *     canEdit (boolean):\n *         Whether the draft comment can be edited.\n *\n *     canSave (boolean):\n *         Whether the draft comment can be saved.\n *\n *     editing (boolean):\n *         True if the comment is currently being edited.\n *\n *     extraData (object):\n *         The draft state for the comment's extra data.\n *\n *     comment (RB.BaseComment):\n *         The comment model.\n *\n *     dirty (boolean):\n *         True if the draft comment has been edited but not saved.\n *\n *     openIssue (boolean):\n *         Whether the comment opens an issue.\n *\n *     publishedComments (Array of RB.BaseComment):\n *         The thread of previous comments that this draft is a reply to, if\n *         applicable.\n *\n *     publishedCommentsType (string):\n *         The type of comment that this draft is a reply to, if applicable.\n *\n *     reviewRequest (RB.ReviewRequest):\n *         The review request that the comment is on.\n *\n *     richText (boolean):\n *         Whether the comment is formatted in Markdown.\n *\n *     text (string):\n *         The comment's text.\n */\nRB.CommentEditor = Backbone.Model.extend(_.defaults({\n    /**\n     * Return the default values for the model attributes.\n     *\n     * Returns:\n     *     object:\n     *     The default values for the attributes.\n     */\n    defaults() {\n        const userSession = RB.UserSession.instance;\n\n        return {\n            canDelete: false,\n            canEdit: undefined,\n            canSave: false,\n            editing: false,\n            extraData: {},\n            comment: null,\n            dirty: false,\n            openIssue: userSession.get('commentsOpenAnIssue'),\n            publishedComments: [],\n            publishedCommentsType: null,\n            requireVerification: false, // TODO: add a user preference for this.\n            reviewRequest: null,\n            richText: userSession.get('defaultUseRichText'),\n            text: '',\n        };\n    },\n\n    /**\n     * Initialize the comment editor.\n     */\n    initialize() {\n        const reviewRequest = this.get('reviewRequest');\n\n        this.on('change:comment', this._updateFromComment, this);\n        this._updateFromComment();\n\n        /*\n         * Unless a canEdit value is explicitly given, we want to compute\n         * the proper state.\n         */\n        if (this.get('canEdit') === undefined) {\n            reviewRequest.on('change:hasDraft', this._updateCanEdit, this);\n            this._updateCanEdit();\n        }\n\n        this.on('change:dirty', (model, dirty) => {\n            const reviewRequestEditor = this.get('reviewRequestEditor');\n\n            if (reviewRequestEditor) {\n                if (dirty) {\n                    reviewRequestEditor.incr('editCount');\n                } else {\n                    reviewRequestEditor.decr('editCount');\n                }\n            }\n        });\n\n        this.on(\n            'change:openIssue change:requireVerification ' +\n            'change:richText change:text',\n            () => {\n                if (this.get('editing')) {\n                    this.set('dirty', true);\n                    this._updateState();\n                }\n            });\n\n        this._updateState();\n\n        this._setupExtraData();\n    },\n\n    /**\n     * Set the editor to begin editing a new or existing comment.\n     */\n    beginEdit() {\n        console.assert(this.get('canEdit'),\n                       'beginEdit() called when canEdit is false.');\n        console.assert(this.get('comment'),\n                       'beginEdit() called when no comment was first set.');\n\n        this.set({\n            dirty: false,\n            editing: true,\n        });\n\n        this._updateState();\n    },\n\n    /**\n     * Delete the current comment, if it can be deleted.\n     *\n     * This requires that there's a saved comment to delete.\n     *\n     * The editor will be marked as closed, requiring a new call to beginEdit.\n     */\n    deleteComment() {\n        console.assert(this.get('canDelete'),\n                       'deleteComment() called when canDelete is false.');\n\n        const comment = this.get('comment');\n        comment.destroy({\n            success: () => {\n                this.trigger('deleted');\n                this.close();\n            },\n        });\n    },\n\n    /**\n     * Cancel editing of a comment.\n     *\n     * If there's a saved comment and it's been made empty, it will end\n     * up being deleted. Then this editor will be marked as closed,\n     * requiring a new call to beginEdit.\n     */\n    cancel() {\n        const comment = this.get('comment');\n\n        this.off('change:comment', this._updateFromComment, this);\n\n        if (comment) {\n            comment.destroyIfEmpty();\n            this.trigger('canceled');\n        }\n\n        this.close();\n    },\n\n    /**\n     * Close editing of the comment.\n     *\n     * The comment state will be reset, and the \"closed\" event will be\n     * triggered.\n     *\n     * To edit a comment again after closing it, the proper state must be\n     * set again and beginEdit must be called.\n     */\n    close() {\n        /* Set this first, to prevent dirty firing. */\n        this.set('editing', false);\n\n        this.set({\n            comment: null,\n            dirty: false,\n            extraData: new RB.ExtraData(),\n            text: '',\n        });\n\n        this.trigger('closed');\n    },\n\n    /**\n     * Save the comment.\n     *\n     * If this is a new comment, it will be created on the server.\n     * Otherwise, the existing comment will be updated.\n     *\n     * The editor will not automatically be marked as closed. That is up\n     * to the caller.\n     *\n     * Args:\n     *     options (object, optional):\n     *         Options for the save operation.\n     *\n     *     context (object, optional):\n     *         The context to use when calling callbacks.\n     */\n    save(options={}, context=undefined) {\n        console.assert(this.get('canSave'),\n                       'save() called when canSave is false.');\n\n        const extraData =  _.clone(this.get('extraData'));\n        extraData.require_verification = this.get('requireVerification');\n\n        const comment = this.get('comment');\n        comment.set({\n            text: this.get('text'),\n            issueOpened: this.get('openIssue'),\n            extraData: extraData,\n            richText: this.get('richText'),\n            includeTextTypes: 'html,raw,markdown',\n        });\n\n        comment.save({\n            success: () => {\n                this.set('dirty', false);\n                this.trigger('saved');\n\n                if (_.isFunction(options.success)) {\n                    options.success.call(context);\n                }\n            },\n\n            error: _.isFunction(options.error)\n                   ? options.error.bind(context)\n                   : undefined,\n        });\n    },\n\n    /**\n     * Update the state of the editor from the currently set comment.\n     */\n    _updateFromComment() {\n        const oldComment = this.previous('comment');\n        const comment = this.get('comment');\n\n        if (oldComment) {\n            oldComment.destroyIfEmpty();\n        }\n\n        if (comment) {\n            const defaultRichText = this.defaults().richText;\n\n            /*\n             * Set the attributes based on what we know at page load time.\n             *\n             * Note that it is *possible* that the comments will have changed\n             * server-side since loading the page (if the user is reviewing\n             * the same diff in two tabs). However, it's unlikely.\n             *\n             * Doing this before the ready() call ensures that we'll have the\n             * text and state up-front and that it won't overwrite what the\n             * user has typed after load.\n             *\n             * Note also that we'll always want to use our default richText\n             * value if it's true, and we'll fall back on the comment's value\n             * if false. This is so that we can keep a consistent experience\n             * when the \"Always edit Markdown by default\" value is set.\n             */\n            this.set({\n                dirty: false,\n                extraData: comment.get('extraData'),\n                openIssue: comment.get('issueOpened') === null\n                           ? this.defaults().openIssue\n                           : comment.get('issueOpened'),\n                requireVerification: comment.requiresVerification(),\n                richText: defaultRichText || !!comment.get('richText'),\n            });\n\n            /*\n             * We'll try to set the one from the appropriate text fields, if it\n             * exists and is not empty. If we have this, then it came from a\n             * previous save. If we don't have it, we'll fall back to \"text\",\n             * which should be normalized content from the initial page load.\n             */\n            const textFields = (comment.get('richText') || !defaultRichText\n                                ? comment.get('rawTextFields')\n                                : comment.get('markdownTextFields'));\n\n            this.set('text',\n                     !_.isEmpty(textFields)\n                     ? textFields.text\n                     : comment.get('text'));\n\n            comment.ready({\n                ready: this._updateState,\n            }, this);\n        }\n    },\n\n    /**\n     * Update the canEdit state of the editor.\n     *\n     * This is based on the authentication state of the user, and\n     * whether or not there's an existing draft for the review request.\n     */\n    _updateCanEdit() {\n        const reviewRequest = this.get('reviewRequest');\n        const userSession = RB.UserSession.instance;\n\n        this.set('canEdit',\n                 userSession.get('authenticated') &&\n                 !userSession.get('readOnly') &&\n                 !reviewRequest.get('hasDraft'));\n    },\n\n    /**\n     * Update the capability states of the editor.\n     *\n     * Some of the can* properties will change to reflect the various\n     * actions that can be performed with the editor.\n     */\n    _updateState() {\n        const canEdit = this.get('canEdit');\n        const editing = this.get('editing');\n        const comment = this.get('comment');\n\n        this.set({\n            canDelete: canEdit && editing && comment && !comment.isNew(),\n            canSave: canEdit && editing && this.get('text') !== '',\n        });\n    },\n}, RB.ExtraDataMixin));\n"]}