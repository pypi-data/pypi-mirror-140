
Cryptainer format
============================

The data recorded by a WitnessAngel device is encrypted and stored into flexible "cryptainers".
The idea is to allow media recordings to be encrypted and signed by several entities, one layer after the other.

The cryptoconf, a configuration tree with a structure similar to that of the final cryptainer tree, is used to specify which algorithms and trustees the encryption/signing process must use.

The final serialization of the cryptainer to disk is done using Pymongo's Extended Json dialect; bson might one day be used as an alternative. The encrypted payload can either be stored as base64 inside the cryptainer (inline mode), or in a raw ciphertext file nearby (offloaded mode).

While a `cryptainer_uid` root field uniquely identifies the cryptainer, its `keychain_uid` value can be shared by several cryptainers, which thus end up using a common set of keypairs generated by trustees. The `keychain_uid` can also be overridden at some levels of the conf tree, for specific trustees.

Hint: to convert base64 UUIDs stored in containers to a more natural hexadecimal form, use a converter like https://base64.guru/converter/decode/hex

**Beware, this format is not stable and specified yet.**



Example
---------

Below is a minimal cryptainer configuration in python, with a single encryption layer and its single signature, both backed by the "local" trustee service of the device; this format can't be used in real life of course, since the data is not protected against illegal reads.

Containers can be much more complex: they can have multiples layers of payload encryption, and for each of these layers, multiples signatures can be added, and the symmetric key can be encrypted by multiples trustees; some trustees being mandatory, and some being part of a "shared secret", i.e. a sufficient number of them must provide their key part so that the decryption becomes possible.

::

    from wacryptolib.cryptainer import LOCAL_KEYFACTORY_TRUSTEE_MARKER

    CRYPTOCONF = dict(
        payload_cipher_layers=[
            dict(
                payload_cipher_algo="AES_CBC",
                key_cipher_layers=[
                    dict(
                        key_cipher_algo="RSA_OAEP",
                        key_cipher_trustee=LOCAL_KEYFACTORY_TRUSTEE_MARKER,
                    )
                ],
                payload_signatures=[
                    dict(
                        payload_digest_algo="SHA256",
                        payload_signature_algo="DSA_DSS",
                        payload_signature_trustee=LOCAL_KEYFACTORY_TRUSTEE_MARKER,
                    )
                ],
            )
        ]
    )

Here is the JSON equivalent of this cryptoconf::

    {
       "payload_cipher_layers":[
          {
             "key_cipher_layers":[
                {
                   "key_cipher_algo":"RSA_OAEP",
                   "key_cipher_trustee":{
                      "trustee_type":"local_keyfactory"
                   }
                }
             ],
             "payload_cipher_algo":"AES_CBC",
             "payload_signatures":[
                {
                   "payload_digest_algo":"SHA256",
                   "payload_signature_algo":"DSA_DSS",
                   "payload_signature_trustee":{
                      "trustee_type":"local_keyfactory"
                   }
                }
             ]
          }
       ]
    }

The corresponding cryptainer content, in Pymongo's Extended Json format (base64 bytestrings shortened for clarity), looks like this.
Binary subType 03 means "UUID", whereas subType 00 means raw binary.

::

    {
        "cryptainer_format": "cryptainer_1.0",
        "cryptainer_metadata": null,
        "cryptainer_state": "FINISHED",
        "cryptainer_uid": {
            "$binary": {
                "base64": "Du14m64eb4m/+/uCPAkEqw==",
                "subType": "03"
            }
        },
        "keychain_uid": {
            "$binary": {
                "base64": "Du14m64emE23Dnuw4+aKFA==",
                "subType": "03"
            }
        },
        "payload_cipher_layers": [
            {
                "key_cipher_layers": [
                    {
                        "key_cipher_algo": "RSA_OAEP",
                        "key_cipher_trustee": {
                            "trustee_type": "local_keyfactory"
                        }
                    }
                ],
                "key_ciphertext": {
                    "$binary": {
                        "base64": "eyJkaWdlc3Rfb...JzdWJUeXBlIjogIjAwIn19XX0=",
                        "subType": "00"
                    }
                },
                "payload_cipher_algo": "AES_CBC",
                "payload_macs": {},
                "payload_signatures": [
                    {
                        "payload_digest_value": {
                            "$binary": {
                                "base64": "XgNeHINsXw16Tl...WtknjGh93nMB4v09Y=",
                                "subType": "00"
                            }
                        },
                        "payload_digest_algo": "SHA256",
                        "payload_signature_algo": "DSA_DSS",
                        "payload_signature_struct": {
                            "signature_timestamp_utc": {
                                "$numberInt": "1641305798"
                            },
                            "signature_value": {
                                "$binary": {
                                    "base64": "F/q+FZQThx1JnyUCwwh...59NCRreWpf2BK8673qMc=",
                                    "subType": "00"
                                }
                            }
                        },
                        "payload_signature_trustee": {
                            "trustee_type": "local_keyfactory"
                        }
                    }
                ]
            }
        ],
        "payload_ciphertext_struct": {
            "ciphertext_location": "inline",
            "ciphertext_value": {
                "$binary": {
                    "base64": "+6CAsNlLHTHFxVcw6M9p/SK...axRM3poryDA/BP9tBeaFU4Y=",
                    "subType": "00"
                }
            }
        }
    }

